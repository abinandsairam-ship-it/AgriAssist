/**
 * @fileoverview Firestore Security Rules for Agriassist.
 *
 * Core Philosophy:
 * This ruleset prioritizes security and data ownership, ensuring users can only
 * access and modify their own data unless explicitly permitted. The rules
 * are designed to be flexible during the prototyping phase, focusing on
 * authorization and less on strict data validation.
 *
 * Data Structure:
 * The Firestore database contains two main collections: `crop_data` and `history`.
 * - `crop_data`: Stores user-submitted crop entries, with each document identified by `entryId`.
 * - `history`: Stores an audit log of user actions, with each event identified by `historyId`.
 *
 * Key Security Decisions:
 * - Users can only create, update, or delete their own crop entries.
 * - The `history` collection is write-only (append-only). Only authenticated users can add history records.
 * - Data validation is minimal in this prototyping phase, focusing on ownership and relational integrity.
 *
 * Denormalization for Authorization:
 * The `crop_data` document denormalizes the `userId` to enable simple ownership checks.
 *
 * Structural Segregation:
 * There is no separation of public and private data in this version. All data requires authentication.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user-submitted crop data entries.
     * @path /crop_data/{entryId}
     * @allow (create) - Authenticated user creates a new entry with their own user ID.
     * @allow (update) - Authenticated user updates their existing entry.
     * @allow (delete) - Authenticated user deletes their existing entry.
     * @deny  (create) - Unauthenticated user attempts to create an entry.
     * @deny  (update) - Authenticated user attempts to update an entry they don't own.
     * @deny  (delete) - Authenticated user attempts to delete an entry they don't own.
     * @principle Enforces document ownership for writes.
     */
    match /crop_data/{entryId} {
      // Helper function to check if the current user is the owner of the document.
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      // Helper function to check if the current user is the owner of the existing document.
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      // Allow anyone to read crop data.
      allow get, list: if true;

      // Only allow authenticated users to create data, and enforce ownership on create.
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;

      // Only allow the owner to update the data.  Also, ensure userId cannot be changed.
      allow update: if isExistingOwner(resource.data.userId) && request.resource.data.userId == resource.data.userId;

      // Only allow the owner to delete the data.
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Controls access to the history log, only authenticated users can add to it.
     * @path /history/{historyId}
     * @allow (create) - Authenticated user can create a history entry.
     * @deny  (get) - No one can read individual history entries.
     * @deny  (list) - No one can list history entries.
     * @deny  (update) - No one can update history entries.
     * @deny  (delete) - No one can delete history entries.
     * @principle Restricts writing history records to authenticated users only.
     */
    match /history/{historyId} {
      // Only allow authenticated users to create history entries.
      allow create: if isSignedIn();

      // No read access to history entries.
      allow get, list: if false;

      // No updates or deletes to history entries.
      allow update, delete: if false;
    }
  }

  // Helper function to check if the user is signed in.
  function isSignedIn() {
    return request.auth != null;
  }
}