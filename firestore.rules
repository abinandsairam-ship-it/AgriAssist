/**
 * @fileoverview Firestore Security Rules for Agriassist.
 *
 * Core Philosophy:
 * This ruleset prioritizes security and data ownership, ensuring users can only access
 * and modify data they own. Public read access is generally disallowed unless explicitly
 * permitted for specific collections. Data structure integrity is loosely enforced, focusing
 * on relational integrity (e.g., user IDs) rather than comprehensive schema validation,
 * allowing for rapid prototyping and schema evolution.
 *
 * Data Structure:
 * - /crop_data/{entryId}: Stores user-submitted crop data entries. Each entry contains a userId
 *   field indicating the owner.
 * - /history/{historyId}: Stores a log of user actions and events.
 *
 * Key Security Decisions:
 * - User-owned data: Entries in `/crop_data` are secured to allow only the owning user to read,
 *   update, or delete them.
 * - Public listing disabled: Listing of entries in `/crop_data` is disallowed to prevent unintended
 *   exposure of user data.  If public listing is needed, the data model should be changed to
 *   use separate private and public collections or a top-level public collection with an ownerId.
 * - History is write-only by the server: Only the server can create history entries.
 *
 * Denormalization for Authorization:
 * - The `userId` field is included directly in the `/crop_data/{entryId}` documents to allow for
 *   efficient ownership checks without requiring additional `get()` operations.
 *
 * Structural Segregation:
 * - No structural segregation is used in this version.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secures user-submitted crop data entries. Only the owner can read, update, or delete entries. Listing is disabled.
     * @path /crop_data/{entryId}
     * @allow (get) User A can read entryA if entryA.userId == userA.uid.
     * @allow (create) User A can create entryA if entryA.userId == userA.uid.
     * @allow (update) User A can update entryA if entryA.userId == userA.uid and the document exists.
     * @allow (delete) User A can delete entryA if entryA.userId == userA.uid and the document exists.
     * @deny (get) User B cannot read entryA if entryA.userId == userA.uid and userA.uid != userB.uid.
     * @deny (create) User B cannot create entryA if entryA.userId == userA.uid and userA.uid != userB.uid.
     * @deny (update) User B cannot update entryA if entryA.userId == userA.uid and userA.uid != userB.uid.
     * @deny (delete) User B cannot delete entryA if entryA.userId == userA.uid and userA.uid != userB.uid.
     * @principle Enforces document ownership for all operations on crop data entries.
     */
    match /crop_data/{entryId} {
      // Read rules
      allow get: if isSignedIn() && isOwner(resource.data.userId);
      allow list: if false;

      // Write rules
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.userId;
      allow update: if isSignedIn() && isExistingOwner(resource.data.userId) && (resource.data.userId == request.resource.data.userId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.userId);
    }

    /**
     * @description Secures history entries. Only the server (or admin) should be able to write history entries. Users cannot read history.
     * @path /history/{historyId}
     * @allow (create) The server can create history entries (assuming it has a way to authenticate).
     * @deny (get) No one can read history entries.
     * @deny (list) No one can list history entries.
     * @deny (update) No one can update history entries.
     * @deny (delete) No one can delete history entries.
     * @principle Restricts history modifications to the server to maintain audit trail integrity.
     */
    match /history/{historyId} {
      // Read rules
      allow get: if false;
      allow list: if false;

      // Write rules
      allow create: if false; // TODO: Implement service account authentication for server-side writes
      allow update: if false;
      allow delete: if false;
    }
  }

  // Helper functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  function isExistingOwner(userId) {
    return isSignedIn() && isOwner(userId) && resource != null;
  }
}